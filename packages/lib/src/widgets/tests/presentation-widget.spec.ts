import { afterEach, beforeEach, describe, expect, it, MockInstance, vi } from 'vitest';
import { PresentationWidget } from '@/widgets/presentation-widget';
import { WidgetConfiguration } from '@/interfaces/widget-configuration';
import { PresentationService } from '@/services/presentation.service';
import { Presentation } from '@/interfaces/presentation';

vi.mock('@/services/presentation.service');
vi.mock('../../../../package.json', () => ({
  version: '1.0.0',
}));

describe('PresentationWidget', () => {
  const mockConfiguration: WidgetConfiguration = {
    guid: 'test-guid',
    host: 'example.com',
    selector: '.widget-container',
    sortBy: 'created',
    sortOrder: 'DESCENDING',
    widgetOptions: {
      playbackMode: 'inline',
    },
  };

  const mockPresentation: Presentation = {
    guid: 'test-guid',
    player: 'https://example.com/player',
    thumbnail: {
      autoGenerated: false,
      cdnUrl: 'https://example.com/thumbnail.jpg',
      height: 200,
      url: 'https://example.com/thumbnail.jpg',
      width: 300,
    },
    title: 'Test Presentation',
  };

  let container: HTMLElement;
  let getPresentationMock: MockInstance;

  beforeEach(() => {
    const div = document.createElement('div');

    div.classList.add('widget-container');
    document.body.appendChild(div);

    container = div;

    getPresentationMock = vi.spyOn(PresentationService.prototype, 'getPresentation')
      .mockResolvedValue(mockPresentation);

    // hide console.error from the widget
    console.error = vi.fn();
  });

  afterEach(() => {
    document.body.innerHTML = '';

    vi.restoreAllMocks();
    vi.clearAllMocks();
  });

  const flushPromises = () => new Promise(setImmediate);

  describe('constructor', () => {
    it('should initialize widget', async () => {
      const widget = await PresentationWidget.create(mockConfiguration);

      expect(widget).toBeDefined();
    });

    it('should validate the configuration and throw an error', async () => {
      const invalidConfig = {
        ...mockConfiguration,
        host: '   ',
      };

      await expect(() => PresentationWidget.create(invalidConfig)).rejects.toThrow('`host` cannot be an empty string');
    });
  });

  describe('version', () => {
    it('should return the widget\'s version', async () => {
      const widget = await PresentationWidget.create(mockConfiguration);

      expect(widget.version).toEqual('1.0.0');
    });
  });

  describe('init', () => {
    it('should fetch presentation and mount component', async () => {
      const querySelectorSpy = vi.spyOn(document, 'querySelector');

      await PresentationWidget.create(mockConfiguration);

      await flushPromises();

      expect(getPresentationMock).toHaveBeenCalledWith(
        'test-guid',
        'created',
        'DESCENDING',
      );

      expect(querySelectorSpy).toHaveBeenCalledWith('.widget-container');
      expect(container.innerHTML)
        .toMatchInlineSnapshot(`"<button type="button" class="qc-thumbnail"><span class="qc-sr-only">Play Presentation: Test Presentation</span><img class="qc-thumbnail__image" src="https://example.com/thumbnail.jpg" alt=""><svg class="qc-thumbnail__play-button qc-thumbnail__play-button--default" aria-hidden="true"><use href="#icon-play"></use></svg></button>"`);
    });

    it('throws error when container element is not found', async () => {
      vi.spyOn(document, 'querySelector').mockReturnValue(null);

      await expect(async () => await PresentationWidget.create(mockConfiguration))
        .rejects
        .toThrow('Element for selector ".widget-container" not found');
    });
  });

  describe('sendTelemetry', () => {
    it('should send the widget configuration to our telemetry service', async () => {
      const fetchSpy = vi.spyOn(window, 'fetch');

      const config: WidgetConfiguration = {
        guid: 'test-guid',
        host: 'example.com',
        selector: '.widget-container',
        sortBy: 'created',
        sortOrder: 'DESCENDING',
        widgetOptions: {
          onIframeLoad() {
            console.log('iframe is loaded');
          },
          playbackMode: 'inline',
        },
      };

      await PresentationWidget.create(config);

      await flushPromises();

      expect(fetchSpy).toHaveBeenCalledWith('https://example.com/widgets-telemetry', {
        body: JSON.stringify({
          guid: 'test-guid',
          host: 'example.com',
          sortBy: 'created',
          sortOrder: 'DESCENDING',
          type: 'presentation',
          version: '1.0.0',
          widgetOptions: {
            playbackMode: 'inline',
            // eslint-disable-next-line sort-keys
            onIframeLoad: true,
            playIcon: {
              height: 44,
              position: 'center',
              width: 44,
            },
          },
        }),
        headers: {
          'Content-Type': 'application/json',
        },
        method: 'POST',
      });
    });

    it('should send the widget configuration to our telemetry service #2', async () => {
      const fetchSpy = vi.spyOn(window, 'fetch');

      const config: WidgetConfiguration = {
        guid: 'test-guid',
        host: 'example.com',
        playerParameters: {
          captions: 'en',
          loop: true,
          reporting: false,
        },
        selector: '.widget-container',
        sortBy: 'created',
        sortOrder: 'DESCENDING',
        widgetOptions: {
          onIframeLoad() {
            console.log('iframe is loaded');
          },
          playbackMode: 'inline',
        },
      };

      await PresentationWidget.create(config);

      await flushPromises();

      expect(fetchSpy).toHaveBeenCalledWith('https://example.com/widgets-telemetry', {
        body: JSON.stringify({
          guid: 'test-guid',
          host: 'example.com',
          playerParameters: {
            captions: 'en',
            loop: true,
            reporting: false,
          },
          sortBy: 'created',
          sortOrder: 'DESCENDING',
          type: 'presentation',
          version: '1.0.0',
          widgetOptions: {
            playbackMode: 'inline',
            // eslint-disable-next-line sort-keys
            onIframeLoad: true,
            playIcon: {
              height: 44,
              position: 'center',
              width: 44,
            },
          },
        }),
        headers: {
          'Content-Type': 'application/json',
        },
        method: 'POST',
      });
    });
  });

  describe('mount', () => {
    it('renders widget with presentation title and player component', async () => {
      await PresentationWidget.create(mockConfiguration);

      await flushPromises();

      expect(container.innerHTML)
        .toMatchInlineSnapshot(`"<button type="button" class="qc-thumbnail"><span class="qc-sr-only">Play Presentation: Test Presentation</span><img class="qc-thumbnail__image" src="https://example.com/thumbnail.jpg" alt=""><svg class="qc-thumbnail__play-button qc-thumbnail__play-button--default" aria-hidden="true"><use href="#icon-play"></use></svg></button>"`);
    });

    it('renders widget with not found message', async () => {
      getPresentationMock.mockRejectedValue(new Error('Presentation not found'));

      await PresentationWidget.create(mockConfiguration);

      await flushPromises();

      expect(container.innerHTML)
        .toMatchInlineSnapshot(`"<div class="qc-not-found"><svg class="qc-icon" width="48" height="48" aria-hidden="true"><use href="#icon-image-broken"></use></svg><div>Presentation not found</div></div>"`);
    });

    it('uses HTMLElement from selector if provided', async () => {
      const querySelectorSpy = vi.spyOn(document, 'querySelector');
      const element = document.createElement('div');

      document.body.appendChild(element);

      const configWithHTMLElement: WidgetConfiguration = {
        ...mockConfiguration,
        selector: element,
      };

      await PresentationWidget.create(configWithHTMLElement);

      await flushPromises();

      expect(querySelectorSpy).not.toHaveBeenCalled();
      expect(element.innerHTML)
        .toMatchInlineSnapshot(`"<button type="button" class="qc-thumbnail"><span class="qc-sr-only">Play Presentation: Test Presentation</span><img class="qc-thumbnail__image" src="https://example.com/thumbnail.jpg" alt=""><svg class="qc-thumbnail__play-button qc-thumbnail__play-button--default" aria-hidden="true"><use href="#icon-play"></use></svg></button>"`);
    });

    it('clears container innerHTML before mounting', async () => {
      const newDiv = document.createElement('div');

      newDiv.innerHTML = 'existing content';
      container.appendChild(newDiv);

      expect(container.innerHTML).toMatchInlineSnapshot(`"<div>existing content</div>"`);

      await PresentationWidget.create(mockConfiguration);

      // Wait for async init to complete
      await flushPromises();

      expect(container.innerHTML)
        .toMatchInlineSnapshot(`"<button type="button" class="qc-thumbnail"><span class="qc-sr-only">Play Presentation: Test Presentation</span><img class="qc-thumbnail__image" src="https://example.com/thumbnail.jpg" alt=""><svg class="qc-thumbnail__play-button qc-thumbnail__play-button--default" aria-hidden="true"><use href="#icon-play"></use></svg></button>"`);
    });

    it('should render DialogComponent when playbackMode is modal', async () => {
      const modalConfiguration: WidgetConfiguration = {
        ...mockConfiguration,
        widgetOptions: {
          ...mockConfiguration.widgetOptions,
          playbackMode: 'modal',
        },
      };

      await PresentationWidget.create(modalConfiguration);

      await flushPromises();

      expect(container.querySelector('.qc-dialog')).not.toBeNull();
    });

    it('should render PlayerComponent when playbackMode is not modal', async () => {
      const nonModalConfiguration: WidgetConfiguration = {
        ...mockConfiguration,
        widgetOptions: {
          ...mockConfiguration.widgetOptions,
          playbackMode: 'inline',
        },
      };

      await PresentationWidget.create(nonModalConfiguration);

      await flushPromises();

      expect(container.querySelector('.qc-dialog')).toBeNull();
      expect(container.querySelector('.qc-thumbnail')).not.toBeNull();
    });

    it('should render PlayerComponent when playbackMode is undefined', async () => {
      const configWithoutPlaybackMode: WidgetConfiguration = {
        ...mockConfiguration,
        widgetOptions: {
          ...mockConfiguration.widgetOptions,
          playbackMode: undefined,
        },
      };

      await PresentationWidget.create(configWithoutPlaybackMode);

      await flushPromises();

      expect(container.querySelector('.qc-dialog')).toBeNull();
      expect(container.querySelector('.qc-thumbnail')).not.toBeNull();
    });

    it('should render the CSS variables', async () => {
      const modalConfiguration: WidgetConfiguration = {
        ...mockConfiguration,
        widgetOptions: {
          style: {
            borderRadius: '24px',
            closeButton: {
              activeBackgroundColor: '#000',
              activeColor: '#111',
              backgroundColor: '#222',
              boxShadow: '1px solid #000',
              color: '#333',
              hoverBackgroundColor: '#444',
              hoverColor: '#555',
              iconSize: '24px',
              padding: '16px',
            },
            dialog: {
              backdropColor: '#000',
              backgroundColor: '#111',
              border: '1px solid #000',
              borderRadius: '16px',
              maxWidth: '1140px',
              padding: '8px',
              width: '50%',
            },
            height: '240px',
            notFound: {
              backgroundColor: '#000',
              border: '1px solid #000',
              color: '#111',
              iconColor: '#222',
            },
            playButton: {
              activeBackgroundColor: '#000',
              activeColor: '#111',
              backgroundColor: '#222',
              color: '#333',
              height: '24px',
              hoverBackgroundColor: '#444',
              hoverColor: '#555',
              margin: '4px',
              padding: '48px',
              position: 'bottom-right',
              width: '48px',
            },
            thumbnail: {
              imageFit: 'none',
            },
            width: '800px',
          },
        },
      };

      const spy = vi.spyOn(container.style, 'setProperty');

      await PresentationWidget.create(modalConfiguration);
      await flushPromises();

      // General widget
      expect(spy).toHaveBeenCalledWith('--qc-pw-aspect-ratio', '16 / 9');
      expect(spy).toHaveBeenCalledWith('--qc-pw-border-radius', '24px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-height', '240px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-width', '800px');

      // Thumbnail
      expect(spy).toHaveBeenCalledWith('--qc-pw-thumbnail-image-fit', 'none');

      // Play button
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-background-color', '#222');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-color', '#333');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-height', '24px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-width', '48px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-margin', '4px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-padding', '48px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-hover-background-color', '#444');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-hover-color', '#555');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-active-background-color', '#000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-active-color', '#111');
      expect(spy).toHaveBeenCalledWith('--qc-pw-play-button-position', 'end end');

      // Dialog
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-backdrop-color', '#000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-background-color', '#111');
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-border', '1px solid #000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-border-radius', '16px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-padding', '8px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-max-width', '1140px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-dialog-width', '50%');

      // Close button
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-background-color', '#222');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-box-shadow', '1px solid #000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-color', '#333');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-padding', '16px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-icon-size', '24px');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-hover-background-color', '#444');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-hover-color', '#555');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-active-background-color', '#000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-close-button-active-color', '#111');

      // Not Found
      expect(spy).toHaveBeenCalledWith('--qc-pw-not-found-background-color', '#000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-not-found-border', '1px solid #000');
      expect(spy).toHaveBeenCalledWith('--qc-pw-not-found-color', '#111');
      expect(spy).toHaveBeenCalledWith('--qc-pw-not-found-icon-color', '#222');
    });

    it('should map the position to the proper CSS value', async () => {
      const spy = vi.spyOn(container.style, 'setProperty');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'top-left',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'start start');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'top',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'start center');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'top-right',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'start end');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'left',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'center start');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'center',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'center center');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'right',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'center end');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'bottom-left',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'end start');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'bottom',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'end center');

      await PresentationWidget.create({
        ...mockConfiguration,
        widgetOptions: {
          style: {
            playButton: {
              position: 'bottom-right',
            },
          },
        },
      });
      await flushPromises();

      expect(spy).toHaveBeenLastCalledWith('--qc-pw-play-button-position', 'end end');
    });
  });

  describe('destroy', () => {
    it('destroy the widget and clean up the DOM', async () => {
      const widget = await PresentationWidget.create(mockConfiguration);

      await flushPromises();

      expect(container.innerHTML)
        .toMatchInlineSnapshot(`"<button type="button" class="qc-thumbnail"><span class="qc-sr-only">Play Presentation: Test Presentation</span><img class="qc-thumbnail__image" src="https://example.com/thumbnail.jpg" alt=""><svg class="qc-thumbnail__play-button qc-thumbnail__play-button--default" aria-hidden="true"><use href="#icon-play"></use></svg></button>"`);

      widget.destroy();

      await flushPromises();

      expect(container.innerHTML).toMatchInlineSnapshot(`""`);
    });

    it('should skip the execution if the widget is already destroyed', async () => {
      const widget = await PresentationWidget.create(mockConfiguration);

      await flushPromises();

      expect(container.innerHTML)
        .toMatchInlineSnapshot(`"<button type="button" class="qc-thumbnail"><span class="qc-sr-only">Play Presentation: Test Presentation</span><img class="qc-thumbnail__image" src="https://example.com/thumbnail.jpg" alt=""><svg class="qc-thumbnail__play-button qc-thumbnail__play-button--default" aria-hidden="true"><use href="#icon-play"></use></svg></button>"`);

      widget.destroy();

      expect(container.innerHTML).toMatchInlineSnapshot(`""`);

      container.innerHTML = 'manually added content';

      widget.destroy(); // second call should be skipped

      expect(container.innerHTML).toMatchInlineSnapshot(`"manually added content"`);
    });
  });
});
